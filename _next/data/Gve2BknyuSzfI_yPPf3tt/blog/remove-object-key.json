{"pageProps":{"post":{"title":"【ES.next】Objectから任意のキーを削除した新しいObjectを作成する","description":"ブログを作る前、Qiitaに投稿しようと書いていたけど途中でやめ、最近まで忘れていた記事です。Qiitaでもいいけど、せっかくだからこっちに置いておきます。","slug":"remove-object-key","tags":["JavaScript","Babel","TypeScript"],"date":"2018-07-13T12:47:36.148Z","update":null,"image":null,"draft":false},"next":{"title":"自作ブログのHTMLをminifyした","description":"HTMLはホワイトスペースの問題があり、minifyする、しないの意見が別れるようだ。私は普段、HTMLまでは行わないのだが、今回はhtml-minifierを使用してHTMLを圧縮したのでそのメモを残しておく。","slug":"html-minify","tags":["html-minifier"],"date":"2018-07-29T14:19:54.882Z","update":null,"image":"/images/html-minify.png","draft":false},"prev":{"title":"ブログをHyperappベースの自作ジェネレータに変更した話","description":"作ったばかりのこのブログだが、Hyperappで動くstaticでSPAなサイトに変更した。React Staticを使用していた時とは違って、HTMLの書き出しなどは自分で処理を行っている。まだ未完成な機能もあるが、ビルド後のJavaScriptが約8KBと軽量で気に入っている。","slug":"use-hyperapp","tags":["blog","Hyperapp"],"date":"2018-07-12T12:45:07.379Z","update":null,"image":"/images/hyperapp.png","draft":false},"sameTags":[{"title":"Rust + wasm-bindgen + WebWorkerの環境構築","description":"WebAssembly Advent Calendar 2018の20日目の記事。","slug":"wasm-bindgen-with-worker","tags":["Rust","wasm-bindgen","TypeScript","parcel"],"date":"2018-12-20T14:58:37.388Z","update":"2019-04-20T13:15:27.878Z","image":null,"draft":false},{"title":"React StaticでTypeScriptを使用した時のエラー対処法","description":"static.config.jsのwebpack設定を変更することで起こるエラーの対処法。","slug":"webpacks-rules-in-static-config-js","tags":["ReactStatic","TypeScript","webpack"],"date":"2018-07-03T11:47:13.910Z","update":null,"image":null,"draft":false},{"title":"ブログで使用した技術","description":"この技術ブログで使用したライブラリやツールを紹介していきます。選定理由についても書きました。","slug":"use-technology","tags":["blog","React","preact","TypeScript","ReactStatic"],"date":"2018-06-30T14:52:29.225Z","update":"2019-04-20T13:15:27.878Z","image":null,"draft":false}],"content":"<h2>はじめに</h2>\n<p>ブログを作る前、Qiitaに投稿しようと書いていたけど途中でやめ、最近まで忘れていた記事です。Qiitaでもいいけど、せっかくだからこっちに置いておきます。</p>\n<h2>削除したいキーが最初から決まっている場合</h2>\n<p>例えばfooキーを削除した新しいオブジェクトを作成する場合、Rest Propertiesを使用し次のように書くことができます。</p>\n<app-code-wrapper lang=\"js\" code=\"const removeFoo = (obj) => {\n  const { foo, ...res } = obj\n\n  return res\n}\n\nremoveFoo({ foo: &#x27;&#x27;, bar: 0 }) // { bar: 0 }\"><pre class=\"shiki\" style=\"background-color: #1E1E1E\"><code><span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">removeFoo</span><span style=\"color: #D4D4D4\"> = (</span><span style=\"color: #9CDCFE\">obj</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">=&gt;</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #4FC1FF\">foo</span><span style=\"color: #D4D4D4\">, ...</span><span style=\"color: #4FC1FF\">res</span><span style=\"color: #D4D4D4\"> } = </span><span style=\"color: #9CDCFE\">obj</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">res</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">removeFoo</span><span style=\"color: #D4D4D4\">({ </span><span style=\"color: #9CDCFE\">foo:</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #CE9178\">&#39;&#39;</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #9CDCFE\">bar:</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> }) </span><span style=\"color: #6A9955\">// { bar: 0 }</span></span></code></pre></app-code-wrapper>\n<p><code>foo</code>は削除される値というのをわかりやすくするために、\n<code>const { foo: _removed, ...res } = obj</code>\nと、<code>_removed</code>などに変数名を変更してもいいかもしれません。</p>\n<h2>削除したいキーが最初から決まっていない場合</h2>\n<p>では、引数などから与えられたキーを削除するにはどうすればいいのでしょうか。</p>\n<app-code-wrapper lang=\"js\" code=\"const removeKey = (obj, key) => {\n  const res = { ...obj }\n  delete res[key]\n\n  return res\n}\"><pre class=\"shiki\" style=\"background-color: #1E1E1E\"><code><span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">removeKey</span><span style=\"color: #D4D4D4\"> = (</span><span style=\"color: #9CDCFE\">obj</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #9CDCFE\">key</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">=&gt;</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4FC1FF\">res</span><span style=\"color: #D4D4D4\"> = { ...</span><span style=\"color: #9CDCFE\">obj</span><span style=\"color: #D4D4D4\"> }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">delete</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">res</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #9CDCFE\">key</span><span style=\"color: #D4D4D4\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">res</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></app-code-wrapper>\n<p>と書くのは少し抵抗がありますよね。</p>\n<p>いろいろ試していると、次の方法で任意のキーを取り除くことができました。</p>\n<app-code-wrapper lang=\"js\" code=\"const removeKey = (obj, key) => {\n  const { [key]: _removed, ...res } = obj\n\n  return res\n}\n\nremoveKey({ foo: &#x27;&#x27;, bar: 0 }, &#x27;bar&#x27;) // { foo: &#x27;&#x27; }\"><pre class=\"shiki\" style=\"background-color: #1E1E1E\"><code><span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">removeKey</span><span style=\"color: #D4D4D4\"> = (</span><span style=\"color: #9CDCFE\">obj</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #9CDCFE\">key</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">=&gt;</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { [</span><span style=\"color: #9CDCFE\">key</span><span style=\"color: #D4D4D4\">]: </span><span style=\"color: #4FC1FF\">_removed</span><span style=\"color: #D4D4D4\">, ...</span><span style=\"color: #4FC1FF\">res</span><span style=\"color: #D4D4D4\"> } = </span><span style=\"color: #9CDCFE\">obj</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">res</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">removeKey</span><span style=\"color: #D4D4D4\">({ </span><span style=\"color: #9CDCFE\">foo:</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #CE9178\">&#39;&#39;</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #9CDCFE\">bar:</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> }, </span><span style=\"color: #CE9178\">&#39;bar&#39;</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #6A9955\">// { foo: &#39;&#39; }</span></span></code></pre></app-code-wrapper>\n<p>ポイントは、<code>{ [key]: _removed }</code>の部分です。\n<code>{ [key], ...res }</code>としただけでは構文エラーとなります。\nおそらく、この書き方だと取り出す<code>key</code>の名前が不明なためかと思います。</p>\n<h2>まとめ</h2>\n<p>Reduxなどでオブジェクトをimmutableに扱う機会は多いと思います。immutableなHashMapでキーを取り除きたいと思ったときはぜひ使ってみてください！</p>\n<p>この方法は、BabelおよびTypeScriptで動作確認を行いました。両方対応しているということはおそらく仕様にあるということだと思いますが、一度ecma262の仕様から探してみたいですね。</p>"},"__N_SSG":true}